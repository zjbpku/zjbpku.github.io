<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>用 Jetpack Compose 搭建可维护的应用架构 - Fidroid</title>
    <meta name="description" content="结合 ViewModel、单向数据流和 Navigation，构建一套在 Jetpack Compose 下既清晰又可维护的 Android 应用架构。">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.7;
            color: #e5e7eb;
            background: radial-gradient(circle at top, #0f172a, #020617);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 20px 60px;
        }

        header {
            padding: 20px 0 10px;
        }

        .logo {
            font-weight: 700;
            font-size: 1.1rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #38bdf8;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            margin-top: 8px;
            font-size: 0.85rem;
            color: #9ca3af;
            text-decoration: none;
        }

        .back-link span {
            margin-right: 6px;
        }

        .back-link:hover {
            color: #e5e7eb;
        }

        .article-header {
            margin-top: 26px;
            padding: 26px 22px 20px;
            border-radius: 18px;
            border: 1px solid rgba(30,64,175,0.8);
            background: radial-gradient(circle at top left, #1d283a, #020617);
            box-shadow: 0 22px 60px rgba(15,23,42,0.9);
        }

        .article-title {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #f9fafb;
        }

        .article-meta {
            font-size: 0.85rem;
            color: #9ca3af;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 4px;
        }

        .article-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 8px;
        }

        .tag {
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.6);
            color: #9ca3af;
        }

        .lead {
            margin-top: 14px;
            font-size: 0.98rem;
            color: #d1d5db;
        }

        main {
            margin-top: 28px;
            padding: 26px 22px 26px;
            border-radius: 18px;
            border: 1px solid rgba(31,41,55,0.9);
            background: radial-gradient(circle at top, #020617, #020617);
            box-shadow: 0 18px 55px rgba(15,23,42,1);
        }

        h2 {
            margin-top: 26px;
            margin-bottom: 12px;
            font-size: 1.25rem;
            color: #f9fafb;
        }

        h3 {
            margin-top: 20px;
            margin-bottom: 8px;
            font-size: 1.02rem;
            color: #e5e7eb;
        }

        p {
            margin-bottom: 12px;
            font-size: 0.96rem;
            color: #d1d5db;
        }

        ul {
            margin: 6px 0 14px 1.2rem;
        }

        li {
            margin-bottom: 6px;
            font-size: 0.95rem;
            color: #d1d5db;
        }

        .note {
            margin: 16px 0;
            padding: 10px 12px;
            border-radius: 10px;
            border-left: 3px solid #22c55e;
            background: rgba(15,23,42,0.85);
            font-size: 0.9rem;
            color: #cbd5f5;
        }

        pre {
            margin: 14px 0;
            padding: 12px 14px;
            border-radius: 12px;
            background: rgba(15,23,42,0.96);
            overflow-x: auto;
            font-size: 0.82rem;
            border: 1px solid rgba(30,64,175,0.8);
        }

        code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .inline-code {
            padding: 0 4px;
            border-radius: 4px;
            background: rgba(15,23,42,0.9);
            border: 1px solid rgba(31,41,55,0.9);
            font-size: 0.88em;
        }

        a {
            color: #38bdf8;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: 26px;
            font-size: 0.8rem;
            color: #6b7280;
            text-align: left;
        }

        @media (max-width: 768px) {
            .article-header,
            main {
                padding: 20px 16px 20px;
            }

            .article-title {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">Fidroid</div>
            <a href="../index.html#blog" class="back-link">
                <span>←</span> 返回首页
            </a>
        </header>

        <section class="article-header">
            <div class="article-meta">
                <span>2024-03-22</span>
                <span>阅读时间 · 约 18 分钟</span>
            </div>
            <h1 class="article-title">用 Jetpack Compose 搭建可维护的应用架构</h1>
            <div class="article-tags">
                <span class="tag">Jetpack Compose</span>
                <span class="tag">架构设计</span>
                <span class="tag">UDF / MVI</span>
                <span class="tag">状态管理</span>
            </div>
            <p class="lead">
                Compose 自带声明式 UI 能力，但并不会替你解决「状态如何在应用中流动」这一根本问题。
                如果仍然把所有逻辑塞进 Activity / Fragment，那么换了 UI 框架也很难获得长期可维护的架构。
                本文试图结合 ViewModel、单向数据流与 Navigation，给出一套适合在中大型项目中落地的 Compose 架构思路。
            </p>
        </section>

        <main>
            <h2>1. 为什么在 Compose 时代更需要架构</h2>
            <p>
                在经典 View 时代，很多「架构不太优雅」的项目仍然能靠经验和约定运行下去，
                因为 UI 更新是显式的命令式调用。而在 Compose 中，如果没有清晰的状态边界与数据流，
                <strong>Recomposition 很容易放大代码异味</strong>：
            </p>
            <ul>
                <li>同一份状态被多个地方修改，导致 UI 行为不可预测。</li>
                <li>不同 Composable 之间通过回调层层传递，形成新的「回调地狱」。</li>
                <li>导航、权限、错误提示等「横切逻辑」散落在各个 Composable 内部。</li>
            </ul>

            <div class="note">
                简单说：Compose 把 UI 写得更快了，但如果没有合理的架构，技术债也会累积得更快。
            </div>

            <h2>2. UDF：用单向数据流串起状态变化</h2>
            <p>
                单向数据流（Unidirectional Data Flow，简称 UDF）并不是 Compose 专属概念，
                但与声明式 UI 的心智模型天然契合。它通常包含三个元素：
            </p>
            <ul>
                <li><strong>State</strong>：当前 UI 所需的所有数据快照。</li>
                <li><strong>Event / Intent</strong>：用户交互或系统回调产生的「意图」。</li>
                <li><strong>Reducer / Handler</strong>：根据事件更新状态、触发副作用的逻辑。</li>
            </ul>

            <h3>2.1 一个典型的 UDF 状态模型</h3>
            <pre><code>data class ArticleListState(
    val isLoading: Boolean = false,
    val articles: List&lt;Article&gt; = emptyList(),
    val error: String? = null,
    val filterKeyword: String = ""
)

sealed interface ArticleListEvent {
    data class OnKeywordChange(val keyword: String) : ArticleListEvent
    data object OnRefresh : ArticleListEvent
    data class OnArticleClick(val id: String) : ArticleListEvent
}</code></pre>

            <p>
                Compose 端只关心 <span class="inline-code">ArticleListState</span> 如何映射成 UI，
                而不关心状态是如何被修改的；所有修改都统一通过 <span class="inline-code">ArticleListEvent</span> 进入 ViewModel。
            </p>

            <h3>2.2 ViewModel 中的事件处理</h3>
            <pre><code>class ArticleListViewModel(
    private val repository: ArticleRepository,
    private val navigator: ArticleNavigator
) : ViewModel() {

    private val _state = MutableStateFlow(ArticleListState())
    val state: StateFlow&lt;ArticleListState&gt; = _state.asStateFlow()

    fun onEvent(event: ArticleListEvent) {
        when (event) {
            is ArticleListEvent.OnKeywordChange -&gt; {
                _state.update { it.copy(filterKeyword = event.keyword) }
            }
            ArticleListEvent.OnRefresh -&gt; loadArticles()
            is ArticleListEvent.OnArticleClick -&gt; {
                navigator.openArticleDetail(event.id)
            }
        }
    }

    private fun loadArticles() {
        viewModelScope.launch {
            _state.update { it.copy(isLoading = true, error = null) }
            runCatching { repository.fetchArticles() }
                .onSuccess { list -&gt;
                    _state.update { it.copy(isLoading = false, articles = list) }
                }
                .onFailure { t -&gt;
                    _state.update { it.copy(isLoading = false, error = t.message) }
                }
        }
    }
}</code></pre>

            <p>
                注意几件事：</p>
            <ul>
                <li>所有状态更新集中在 ViewModel 内部，Compose 只负责展示。</li>
                <li>导航通过 <span class="inline-code">navigator</span> 这一抽象来实现，避免 Composable 直接依赖 NavController。</li>
                <li>网络请求等副作用都放在 ViewModel 中，便于测试与重用。</li>
            </ul>

            <h2>3. Compose 层：无状态 UI + 状态入口</h2>
            <p>
                从 Compose 的角度来看，理想的结构是：
            </p>
            <ul>
                <li><strong>无状态 UI</strong>：仅通过参数接收状态与回调，不直接持有 ViewModel。</li>
                <li><strong>状态入口</strong>：少量「桥接层」负责从 ViewModel 收集状态，并调用无状态 UI。</li>
            </ul>

            <h3>3.1 状态入口 Composable</h3>
            <pre><code>@Composable
fun ArticleListRoute(
    viewModel: ArticleListViewModel = viewModel()
) {
    val state by viewModel.state.collectAsState()

    ArticleListScreen(
        state = state,
        onEvent = viewModel::onEvent
    )
}</code></pre>

            <h3>3.2 无状态 UI</h3>
            <pre><code>@Composable
fun ArticleListScreen(
    state: ArticleListState,
    onEvent: (ArticleListEvent) -&gt; Unit
) {
    Column {
        SearchBar(
            keyword = state.filterKeyword,
            onKeywordChange = { onEvent(ArticleListEvent.OnKeywordChange(it)) },
            onSearch = { onEvent(ArticleListEvent.OnRefresh) }
        )

        if (state.isLoading) {
            CircularProgressIndicator()
        } else if (state.error != null) {
            ErrorView(
                message = state.error,
                onRetry = { onEvent(ArticleListEvent.OnRefresh) }
            )
        } else {
            ArticleList(
                articles = state.articles,
                onArticleClick = { id -&gt; onEvent(ArticleListEvent.OnArticleClick(id)) }
            )
        }
    }
}</code></pre>

            <p>
                这样的拆分让 UI 与状态管理之间的边界极其清晰：<strong>任何时候只要你拿到一份完整的
                <span class="inline-code">ArticleListState</span>，就可以独立预览 / snapshot 这一屏的 UI。</strong>
            </p>

            <h2>4. Navigation 与跨屏状态</h2>
            <p>
                在 Compose 世界中，推荐使用官方的 <span class="inline-code">Navigation-Compose</span>，并遵守几个简单规则：
            </p>
            <ul>
                <li>路由字符串尽量语义化，例如 <span class="inline-code">"article/list"</span>、<span class="inline-code">"article/detail/{id}"</span>。</li>
                <li>不要在 Composable 内部随意 new NavController，而是通过上层注入或抽象导航接口。</li>
                <li>跨屏共享的状态（例如登录信息、全局配置）放在更高层级的 ViewModel，而不是通过 navArgs 硬传。</li>
            </ul>

            <pre><code>@Composable
fun AppNavHost(
    navController: NavHostController,
    modifier: Modifier = Modifier
) {
    NavHost(
        navController = navController,
        startDestination = "article/list",
        modifier = modifier
    ) {
        composable("article/list") {
            ArticleListRoute()
        }
        composable(
            route = "article/detail/{id}",
            arguments = listOf(navArgument("id") { type = NavType.StringType })
        ) { backStackEntry -&gt;
            val id = backStackEntry.arguments?.getString("id") ?: return@composable
            ArticleDetailRoute(articleId = id)
        }
    }
}</code></pre>

            <h2>5. 关于性能：架构与 Recomposition 的协作</h2>
            <p>
                很多性能问题并不是 Compose 本身带来的，而是由于架构设计导致「状态过于粗粒度」：
                当一个巨大的 State 对象被修改时，整棵 UI 树都被迫 Recompose。
            </p>
            <p>一些实践建议：</p>
            <ul>
                <li>拆分 State，使局部 UI 只依赖必要字段。</li>
                <li>使用 <span class="inline-code">derivedStateOf</span> 把计算型状态缓存下来，避免在 Recomposition 中重复做重计算。</li>
                <li>合理使用 <span class="inline-code">LazyColumn</span> 等懒加载组件，并为列表元素提供稳定的 key。</li>
            </ul>

            <pre><code>val filteredArticles by remember(state.articles, state.filterKeyword) {
    derivedStateOf {
        state.articles.filter { article -&gt;
            article.title.contains(state.filterKeyword, ignoreCase = true)
        }
    }
}</code></pre>

            <p>
                架构的目标不是「追求极致的 Recomposition 次数」，而是让你能清楚地知道<strong>是谁</strong>在更新<strong>哪一块</strong> UI，
                并在必要时有能力优化它。
            </p>

            <h2>6. 总结：一套可以长期演进的 Compose 架构</h2>
            <p>将本文内容压缩成一个 checklist，大致可以是：</p>
            <ul>
                <li>所有屏幕都有明确的 State / Event 定义。</li>
                <li>ViewModel 是状态与副作用的唯一「入口」，Composable 不直接做网络 / 数据库访问。</li>
                <li>大部分 UI 组件保持「无状态 + 参数驱动」，方便复用与预览。</li>
                <li>Navigation 有统一管理入口，路由命名语义化，跨屏状态通过更高层级的 ViewModel 管理。</li>
                <li>针对性能问题，有手段定位和优化 Recomposition 热点。</li>
            </ul>

            <p>
                在此基础上，你可以根据团队规模和项目特点，继续引入更多工程实践（例如模块化、功能边界拆分、统一 Design System 等）。
                Compose 提供了强大的 UI 能力，而一套清晰的架构，则能保证这些能力在未来几年里继续为你的项目稳定服务。
            </p>
        </main>

        <footer>
            本文首发于 Fidroid · Android &amp; Jetpack Compose 博客。
        </footer>
    </div>
</body>
</html>


